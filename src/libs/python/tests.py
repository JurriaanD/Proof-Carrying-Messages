# Usage: python tests.py [port]
# To install pyserial, run pip install pyserial or conda install pyserial
# To intall pycrypto, run pip install pycrypto
# This scripts generates random strings and checks if the hash calculated by the
# arduino matches the hash generated by python's crypto functions
import sys
import random
from string import ascii_lowercase
import hashlib
from termcolor import colored
from comm import SerialComm
from util import Opcodes
from aes import AESCipher

SHA256_TESTS = 50
MD5_TESTS = 50
AES_ECB_TESTS = 50
AES_CBC_TESTS = 50
AES_CTR_TESTS = 50

def random_string(string_length=10):
    """ Generates a random string of the specified length """
    letters = ascii_lowercase
    return ''.join(random.choice(letters) for i in range(string_length))

def test_hash(comm, nb_tests, opcode, hashfunc):
    """ Generic function to test hash generation """
    failed = False
    for _ in range(nb_tests):
        string = random_string(random.randint(10, 15))
        comm.write_serial_string(f"{opcode} {string}")
        python_solution = hashfunc(string.encode()).hexdigest()
        arduino_solution = comm.read_serial()
        if python_solution != arduino_solution:
            print(colored(f"✗ Failed with input string '{string}'! Python gives {python_solution} while the arduino gives {arduino_solution}", "red", attrs=["bold"]))
            failed = True
    if not failed:
        print(colored(f"✓ All {nb_tests} test succeeded!", 'green', attrs=["bold"]))

def test_aes_ecb(comm, nb_tests):
    """ Test AES EBC """
    failed = False
    cipher = AESCipher(comm.symm_key)
    for _ in range(nb_tests):
        string = random_string(random.randint(0, 40))
        comm.write_serial_string(str(Opcodes.AES_ECB) + " " + string)
        arduino_solution = comm.read_serial()
        python_solution = ''.join('{:02x}'.format(x) for x in cipher.encryptECB(string))
        if python_solution != arduino_solution:
            print(colored(f"✗ Failed with input string '{string}'! Python gives {python_solution} while the arduino gives {arduino_solution}", "red", attrs=["bold"]))
            failed = True
    if not failed:
        print(colored(f"✓ All {nb_tests} test succeeded!", 'green', attrs=["bold"]))

def test_aes_cbc(comm, nb_tests):
    """ Test AES CBC """
    failed = False
    cipher = AESCipher(comm.symm_key)
    for _ in range(nb_tests):
        string = random_string(random.randint(0, 40))
        init_vector = random_string(16)
        comm.write_serial_string(f"{Opcodes.AES_CBC} {init_vector}{string}")
        arduino_solution = comm.read_serial()
        python_solution = ''.join('{:02x}'.format(x) for x in cipher.encryptCBC(string, bytes(init_vector, "utf-8")))
        if python_solution != arduino_solution:
            print(colored(f"✗ Failed with input string '{string}'! Python gives {python_solution} while the arduino gives {arduino_solution}", "red", attrs=["bold"]))
            failed = True
    if not failed:
        print(colored(f"✓ All {nb_tests} test succeeded!", 'green', attrs=["bold"]))

def test_aes_ctr(comm, nb_tests):
    """ Test AES CTR """
    failed = False
    cipher = AESCipher(comm.symm_key)
    for _ in range(nb_tests):
        string = random_string(random.randint(15, 40))
        init_vector = random_string(16)
        comm.write_serial_string(f"{Opcodes.AES_CTR} {init_vector}{string}")
        arduino_solution = comm.read_serial()
        cipher.setCounterValue(int.from_bytes(bytes(init_vector, "utf-8"), byteorder="big"))
        python_solution = ''.join('{:02x}'.format(x) for x in cipher.encryptCTR(string))
        if python_solution != arduino_solution:
            print(colored(f"✗ Failed with input string '{string}'! Python gives {python_solution} while the arduino gives {arduino_solution}", "red", attrs=["bold"]))
            failed = True
    if not failed:
        print(colored(f"✓ All {nb_tests} test succeeded!", 'green', attrs=["bold"]))

def run_tests(comm: SerialComm) -> None:
    """ Runs the test suite (md5, sha256 and aes ecb/cbc/ctr) """
    if not comm.has_symm_key():
        comm.negotiate_symm_key()
    print(comm.read_serial()) # Response from negotiating

    print("Starting SHA256 tests...")
    test_hash(comm, SHA256_TESTS, Opcodes.SHA256, hashlib.sha256)
    print("Starting MD5 tests...")
    test_hash(comm, MD5_TESTS, Opcodes.MD5, hashlib.md5)
    print("Starting AES tests with ECB mode...")
    test_aes_ecb(comm, AES_ECB_TESTS)
    print("Starting AES tests with CBC mode...")
    test_aes_cbc(comm, AES_CBC_TESTS)
    print("Starting AES tests with CTR mode...")
    test_aes_ctr(comm, AES_CTR_TESTS)

if __name__ == "__main__":
    COMM = SerialComm(sys.argv[1] if len(sys.argv) > 1 else None)
    COMM.read_serial() # "Arduino ready..." message
    run_tests(COMM)
